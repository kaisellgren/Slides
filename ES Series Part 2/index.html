<!DOCTYPE html> 
<!--
	Copyright 2010 Google Inc.
 
	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at
 
		 http://www.apache.org/licenses/LICENSE-2.0
 
	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.
 
	Original slides: Marcin Wichary (mwichary@google.com)
	Modifications: Chrome Developer Relations <chrome-devrel@googlegroups.com>
-->
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=Edge;chrome=1" />
	<title>ECMAScript Series Part 2</title>
	<link href="http://fonts.googleapis.com/css?family=Droid+Sans|Droid+Sans+Mono" rel="stylesheet" type="text/css" />
	<link href="../styles/slides.css" rel="stylesheet" type="text/css" />
	<style>
		body {
			background: url('../images/background2.jpg');
		}
	</style>
</head>
<body>
	<div class="inner-shadow"></div>

	<div class="presentation">
		<div id="presentation-counter"></div>
		<div class="slides">
			<div class="slide">
				<section class="middle">
					<h1 class="title">ECMAScript Series Part 2:<br /><br />Scopes and declarations</h1>
					<p>by Kai Sellgren</p>
				</section>
			</div>

			<div class="slide">
				<section class="middle">
					<h1 class="title">Scopes</h1>
				</section>
			</div>

			<div class="slide">
				<section>
					<h2>Scope</h2>
					<div data-build="data-build">
						<blockquote>"Scope is an enclosing context where values and expressions are associated. The type of scope determines what kind of entities it can contain and how it affects them—or semantics." -- Wikipedia</blockquote>
						<p>Typically, scope is used to define the extent of information hiding. That is, the visibility or accessibility of variables from different parts of the program.</p>
						<p>Scopes can:</p>
						<ul>
							<li>contain declarations or definitions of identifiers;</li>
							<li>contain statements and/or expressions which define an executable algorithm or part thereof;</li>
							<li>nest or be nested.</li>
						</ul>
						<p>Variables are associated with scopes. Different scoping rules affect how local variables are bound. This has different consequences depending on whether the language has static (lexical) or dynamic scoping.</p>
						<p>Scopes are also often referred to as <em>environments</em>.</p>
					</div>
				</section>
			</div>

			<div class="slide">
				<section>
					<h2>ECMAScript has Lexical scoping</h2>
					<div data-build="data-build">
						<p>With lexical scope, a name always refers to its (more or less) local lexical environment. Because this matching only requires analysis of the static program text, this type of scoping is also called static scoping.</p>
						<p>Static scoping allows the programmer to reason about object references such as parameters, variables, constants, types, functions, etc. as simple name substitutions. This makes it much easier to make modular code and reason about it, since the local naming structure can be understood in isolation.</p>
						<p>In ECMAScript, every function defines a new scope. This is called function scoping.</p>
						<p>We will possibly have block scoping in ECMAScript 6 "Harmony", but that is not sure yet.</p>
					</div>
				</section>
			</div>

			<div class="slide">
				<section>
					<h2>Example use of Lexical scoping</h2>
					<pre>
function foo() {
	var a = 'Hello';

	function bar() {
		var b = ' world!';
		console.log(a + b); // Hello world!
	}

	console.log(a + b); // Hello undefined
}

foo();
</pre>
					<div data-build="data-build">
						<p>There are three scopes in the above code and the function <em>bar</em> uses Lexical scoping, because in ECMAScript we have function-based scoping rules.</p>
					</div>
				</section>
			</div>

			<div class="slide">
				<section>
					<h2>Scope resolution</h2>
					<p><em>Scope resolution</em> (identifier resolution) is used for finding symbols such as variables within a <em>scope chain</em>.</p>
					<div data-build="data-build">
						<pre>
var a = 1;                    <strong>Program scope:</strong>
function foo() {               a: 1
    var b = 2;
    function bar() {          <strong>Function scope "foo":</strong>
        var c = 3;             b: 2
        c - b - a; // 0
    }                         <strong>Function scope "bar":</strong>
};                             c: 3
</pre>
						<p>When executing function <em>bar</em>, the symbol <em>a</em> is retrieved through scope resolution like so:</p>
						<ul>
							<li>See if <em>a</em> is defined in this (local) scope</li>
							<ul data-build="data-build">
								<li>Yes - use it</li>
								<li><strong>No - see if <em>a</em> is defined in the "foo" scope.</strong></li>
								<ul data-build="data-build">
									<li>Yes - use it</li>
									<li><strong>No - see if <em>a</em> is defined in the Program scope.</strong></li>
									<ul data-build="data-build">
										<li><strong>Yes - use it</strong></li>
										<li>No - throw <em>ReferenceError</em></li>
									</ul>
								</ul>
							</ul>
						</ul>
					</div>
				</section>
			</div>

			<div class="slide">
				<section>
					<h2>How does LexicalEnvironment work?</h2>
					<p>During the process of parsing and compiling the program, the engine will create LexicalEnvironment objects that are stored in functions' [[Scope]] property.</p>
					<pre>
<em>LexicalEnvironment</em>:
    <em>EnvironmentRecord</em> environment:
        ...
    <em>LexicalEnvironment</em> outer:
        ...</pre>
					<div data-build="data-build">
						<p>Each <em>LexicalEnvironment</em> objects contain a reference to the outer environment, which can be a null reference.</p>
						<p>They have a single <em>EnvironmentRecord</em> object which holds each symbol inside.</p>
					</div>
				</section>
			</div>

			<div class="slide">
				<section>
					<h2>LexicalEnvironment example</h2>
					<pre>
var x = 1;
function foo() {
    var y = 2;
}</pre>
					<pre>
<em>LexicalEnvironment</em> programScope:
    <em>EnvironmentRecord</em> environment:
        // "Built-in features" in global scope
        Date: function() {}
        Array: function() {}
        ...
        x: 1
    <em>LexicalEnvironment</em> outer: null</pre>
					<pre>
<em>LexicalEnvironment</em> fooScope:
    <em>EnvironmentRecord</em> environment:
        y: 2
    <em>LexicalEnvironment</em> outer: programScope</pre>
					<p><em>LexicalEnvironment</em> objects are used in scope/identifier resolution. All this forms a so-called <em>scope chain</em>.</p>
				</section>
			</div>

			<div class="slide">
				<section>
					<h2>Types of EnvironmentRecord</h2>
					<p>There are two types of <em>EnvironmentRecord</em>. First is the <em>declarative environment record</em>, which holds variables, functions, formal parameters and such.</p>
					<div data-build="data-build">
						<p>These declarative records can be very efficient and are often stored low level in the registers of virtual machines. They are created with several optimizations such as completely
						omitting unnecessary symbols.</p>
						<img src="withoutEval.png" />
					</div>
				</section>
			</div>

			<div class="slide">
				<section>
					<h2>Drawbacks of using <em>eval</em></h2>
					<p>One of the several drawbacks to using <em>eval</em> is its inefficiency. Declarative records can no longer be efficient, because the underlying engine has no idea what is going to happen when <em>eval</em> is used.</p>
					<div data-build="data-build">
						<img src="withEval.png" />
						<p>The term <em>Closure</em> seen in the above screenshot is the parent environment. The parent environment is "closed up" with the current context, hence it's called a Closure.</p>
					</div>
				</section>
			</div>

			<div class="slide">
				<section>
					<h2>Object environment records</h2>
					<p>The other type of <em>EnvironmentRecord</em> in contrast to the <em>declarative environment record</em> is called the <em>object environment record</em>.</p>
					<div data-build="data-build">
						<p>It is used for the global scope (and also for <em>with</em> statements).</p>
						<pre>
var a = 10;
console.log(a); // 10

// "this" in the global context is the global object itself.
console.log(this.a); // 10

// "window" is the reference to the global object in the browser environment.
console.log(window.a); // 10</pre>
						<p>Removing the global object from the bottom of the scope chain is planned for the ES.next. That is, the global environment record will be also declarative.</p>
						<p>With a system of planned modules, global bindings such as parseInt, Math, etc. will just be imported to the global context. We won’t be able to refer global variables as properties of the global object anymore, since there will be no any global object.</p>
					</div>
				</section>
			</div>

			<div class="slide">
				<section>
					<h2>Closures</h2>
					<blockquote>"A closure is a combination of a code block and data of a context in which this code block is created."</blockquote>
					<pre>
var x = 10;

function foo() {
  console.log(x);
}

(function (f) {
  var x = 20;

  // The variable "x" for "f" is saved statically from the (lexical) context,
  // in which it was created.
  f(); // 10, but not 20
})(foo);
					</pre>
				</section>
			</div>

			<div class="slide">
				<section>
					<h2>Using Closures (and Lexical scoping thereof) cleverly</h2>
					<pre>
function makeGreeter(name) {
    return function() {
        return "Hello " + name + "!";
    }
}

var jackGreeter = makeGreeter('Jack');
var bauerGreeter = makeGreeter('Bauer');

jackGreeter(); // Hello Jack!
bauerGreeter(); // Hello Bauer!</pre>
					<div data-build="data-build">
						<p>The inner anonymous function has become a closure, and "closes up" the scope of the outer function <em>makeGreeter</em> who has the argument <em>name</em> in its scope.</p>
						<p>The <em>name</em> argument is fetched from <em>makeGreeter</em>'s scope via scope resolution and since ECMAScript has Lexical scoping, it will succeed.</p>
					</div>
				</section>
			</div>

			<div class="slide">
				<section>
					<h2>The notorious closure loop</h2>
					<p>This is the mistake that every JavaScript fella commits:</p>
					<pre>
var functions = [];
for (var i = 0; i < 10; i++) {
    functions.push(function() {
        return i;
    });
}

functions.forEach(function(f) {
    console.log(f());
});</pre>
					<div data-build="data-build">
						<p>The above code outputs <em>10</em> exactly ten times, because the functions stored in <em>functions</em> array are closures.</p>
						<pre>
for (var i = 0; i < 10; i++) {
    !function(i) {
        functions.push(function() {
            return i;
        });
    }(i);
}</pre>
					</div>
				</section>
			</div>

			<div class="slide">
				<section>
					<h2>Block-scoped bindings</h2>
					<p>The upcoming ECMAScript 6 "Harmony" edition will likely feature block-scoped bindings:</p>
					<pre>
{
    let x = 5;
    const y = 10;

    console.log(x, y); // 5 and 10
}

console.log(x, y); // undefined and undefined</pre>
					<div data-build="data-build">
						<p>There's also a plan for adding block-scoped functions, but the syntax has not been decided yet.</p>
					</div>
				</section>
			</div>

			<div class="slide">
				<section class="middle">
					<h1 class="title">Declarations</h1>
				</section>
			</div>

			<div class="slide">
				<section>
					<h2>Declarations</h2>
					<p>Declarations are statements that declare a symbol. Declared symbols have the value of <em>undefined</em> initially.</p>
					<div data-build="data-build">
						<p>Declaring variables is as easy as:</p>
						<pre>
var name = "Jack";</pre>
						<p>Even though you can define a global variable by leaving the <em>var</em> keyword, the variable will not be declared.</p>
						<p>ECMAScript syntax intentionally resembles Java syntax and the syntax is relaxed to enable it to serve as an easy-to-use scripting language. For example, a variable is not required to have its type declared nor are types associated with properties, and defined functions are not required to have their declarations appear textually before calls to them.</p>
						<pre>
foo();
function foo() {
    console.log('foo!');
}</pre>
					</div>
				</section>
			</div>

			<div class="slide">
				<section>
					<h2>Hoisting</h2>
					<div data-build="data-build">
						<p>Declarations are said to "hoist" which means that they are defined before entering a new context and executing your code.</p>
						<p>At times this may cause weird problems:</p>
						<pre>
var confirm = confirm('Are you sure?'); // TypeError: undefined is not a function
if (confirm) {
    // Do something...
}						</pre>
						<p>In the above code, one might expect it to pop up a dialog with yes-no buttons. However, due to hoisting, the actual variable declaration is defined before your code gets executed like so:</p>
						<pre>
var confirm;
confirm = confirm('Are you sure?');
if (confirm) {
    // Do something...
}						</pre>
					</div>
				</section>
			</div>

			<div class="slide">
				<section>
					<h2>Hoisting cont'd.</h2>
					<div data-build="data-build">
						<p>One way to solve this issue is to avoid name clash:</p>
						<pre>
var c = confirm('Are you sure?');
if (c) {
    // Do something...
}						</pre>
						<p>Or refer to the function via <em>window</em>:</p>
						<pre>
var confirm;
confirm = window.confirm('Are you sure?');
if (confirm) {
    // Do something...
}						</pre>
					</div>
				</section>
			</div>

			<div class="slide">
				<section>
					<h2>Hoisting cont'd.</h2>
					<div data-build="data-build">
						<p>Because of hoisting, it does not matter if you declare a variable all over again in loops:</p>
						<pre>
for (var i = 0; i < 10; i++) {
    var b = i * i;
}			</pre>
						<p>After all, the above code is executed as:</p>
						<pre>
var b;
for (var i = 0; i < 10; i++) {
    b = i * i;
}						</pre>
					</div>
				</section>
			</div>

			<div class="slide">
				<section>
					<h2>Hoisting cont'd.</h2>
					<div data-build="data-build">
						<p>Hoisting happens per scope as scopes define what symbols are available to us. It is applied during compilation time. Whether the engine compiles to native machine code or some bytecode, hoisting will occur before any of your code is run.</p>
						<p>It should be mentioned that hoisting process makes sure there is only one-time declaration of a symbol, never many:</p>
						<pre>
<em>Your code</em>                           <em>What engine does</em>
var a;                              var a;
console.log(a); // undefined        console.log(a);
a = 1;                              a = 1;
console.log(a); // 1                console.log(a);
var a;
console.log(a); // 1                console.log(a);</pre>
						<p>The initial value of a declared symbol is <em>undefined</em>. However, hoisting makes it impossible to redeclare a symbol.</p>
					</div>
				</section>
			</div>

			<div class="slide">
				<section>
					<h2>Always use <em>var</em> for variables</h2>
					<div data-build="data-build">
						<p>It is important to use the <em>var</em> keyword when declaring variables. Without it, variables end up created in the global scope, undeclared, as an object property.</p>
						<pre>
console.log(typeof a); // undefined
function foo() {
    a = 1;
}
foo();
console.log(typeof a); // "Number"</pre>
						<p>Declared variables go through hoisting process, which sets a [[DontDelete]] flag for them:</p>
						<pre>
<em>Your code</em>                 <em>EnvironmentRecord</em>
function foo() {              bar: {
    var bar = 5;                  value: 5
}                                 DontDelete: true
foo();                        }</pre>
					</div>
				</section>
			</div>

			<div class="slide">
				<section>
					<h2>Inspecting [[DontDelete]]</h2>
					<div data-build="data-build">
						<p>We can inspect this behavior of setting [[DontDelete] flag easily.</p>
						<pre>
function foo() {                 function foo() {
    var a = 1;                       a = 1;
    console.log(a); // 1             console.log(a); // 1
    delete a;                        delete a;
    console.log(a); // 1             console.log(a); // ReferenceError: a is not
}                                }                                      defined
foo();                           foo();</pre>
					</div>
				</section>
			</div>

			<div class="slide">
				<section>
					<h2>Most ECMAScript/JavaScript books are crap</h2>
					<p>The real concepts behind ECMAScript are not always straight-forward. Even the popular JavaScript book "Object-Oriented JavaScript" got some parts wrong.</p>
					<img src="oojs.jpg" style="display: table; margin: 0 auto;" />
				</section>
			</div>

			<div class="slide">
				<section>
					<h2>Declaration confusion</h2>
					<blockquote>"function is treated as a normal variable—it can be copied to a different variable and even deleted." -- Object-Oriented JavaScript</blockquote>
					<div data-build="data-build">
						<p>WRONG!</p>
						<p>The book even continues and provides a code snippet:</p>
						<pre>
>>> var sum = function(a, b) {return a + b;}
>>> var add = sum;
>>> delete sum
true
>>> typeof sum;
"undefined"</pre>
						<p>However, as we learned before, variable declarations end up hoisted and get a [[DontDelete]] flag set. Therefore, the above code snippet should be anything, but right.</p>
						<p>Before we can understand what is going on, we need to take a look at <em>eval</em>.</p>
					</div>
				</section>
			</div>

			<div class="slide">
				<section>
					<h2>Declarations and <em>eval</em></h2>
					<p>Variables declared within <em>eval</em> code are created as properties of calling context's Variable object. Therefore, they do not receive this [[DontDelete]] attribute.</p>
					<div data-build="data-build">
						<pre>
function foo() {
    eval('var bar = 5');
    console.log(bar); // 5
    delete bar;
    console.log(typeof bar); // "undefined"
}
foo();</pre>
						<p>As seen above, evaluated code containing variable declarations will not set [[DontDelete]] attributes. So, why did the book claim the opposite?</p>
					</div>
				</section>
			</div>

			<div class="slide">
				<section>
					<h2>Firebug's behavior</h2>
					<div data-build="data-build">
						<p>Interestingly, as we look into Firebug's source code, we see this in <em>commandLine.js</em>:</p>
						<pre>
Components.utils.evalInSandbox(scriptToEval, sandbox);</pre>
						<p>The method <em>evalInSandbox</em> is an internal method and it does just what it says, runs an evaluation.</p>
						<p>As we remember from before, evaluation can affect the behavior of code as it does in this case.</p>
						<p>This leads me to believe that Stoyan Stefanov, the author of "Object-Oriented JavaScript", has used Firebug to test his code. Since Firebug evaluates the given code, the behavior might be different than what one might expect.</p>
					</div>
				</section>
			</div>

			<div class="slide">
				<section class="middle">
					<h1>Questions?</h1>
				</section>
			</div>

		</div> <!-- slides -->

	</div> <!-- presentation -->

	<script src="../js/slides.js">	</script>
</body>
</html>